// Copyright (C) 2002 IAIK
// http://jce.iaik.at
//
// Copyright (C) 2003 - 2013 Stiftung Secure Information and
//                           Communication Technologies SIC
// http://www.sic.st
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

package demo.x509.ocsp;

import iaik.asn1.structures.AlgorithmID;
import iaik.utils.LineInputStream;
import iaik.utils.URLDecoder;
import iaik.utils.Util;
import iaik.x509.ocsp.BasicOCSPResponse;
import iaik.x509.ocsp.OCSPResponse;
import iaik.x509.ocsp.SingleResponse;
import iaik.x509.ocsp.utils.ResponseGenerator;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.StringTokenizer;
import java.util.TimeZone;

/**
 * Thread for the simple OCSP server {@link demo.x509.ocsp.OCSPServer demo}.
 * <p>
 * This class is part of the IAIK OCSP client - server demo. When starting the
 * demo {@link demo.x509.ocsp.OCSPServer server}, it listens on port 9999 for
 * OCSP requests which may be sent by the IAIK OCSP demo
 * {@link demo.x509.ocsp.OCSPClient client}. For each request posted an
 * OCSPServerThread is created for handling the request.
 * <p>
 * The keys and certificates required for this demo are obtained from the
 * IAIK-JCE demo keystore "jce.keystore" which may be generated by running the
 * {@link demo.keystore.SetupKeyStore SetupKeyStore} program or a read in by the
 * {@link demo.x509.ocsp.OCSPServer OCSPServer}.
 * 
 * @see demo.x509.ocsp.OCSPServer
 * @see demo.x509.ocsp.OCSPClient
 * @see demo.x509.ocsp.HttpOCSPClient
 * @version File Revision <!-- $$Revision: --> 10 <!-- $ -->
 */
public class OCSPServerThread extends Thread {

	private static final String crlf = "\r\n";
	private Socket socket;
	// response generator for parsing request / creating response
	private ResponseGenerator responseGenerator;
	// algorithm to be used for signing the response
	private AlgorithmID signatureAlgorithm;

	/**
	 * Creates an OCSP server thread for handling an OCSPRequest.
	 * 
	 * @param socket
	 *          the socket from which to read the request and to which to send the
	 *          response
	 * @param responseGenerator
	 *          a {@link iaik.x509.ocsp.utils.ResponseGenerator ResponseGenerator}
	 *          object used for request parsing and response creation tasks
	 * @param signatureAlgorithm
	 *          the algorithm used for signing the response
	 */
	public OCSPServerThread(Socket socket,
	                        ResponseGenerator responseGenerator,
	                        AlgorithmID signatureAlgorithm)
	{

		super("OCSPServerThread");
		this.socket = socket;
		this.responseGenerator = responseGenerator;
		this.signatureAlgorithm = signatureAlgorithm;
	}

	/**
	 * Handles the client request.
	 */
	public void run() {
		DataOutputStream out = null;
		LineInputStream in = null;
		try {
			if (OCSPServer.DEBUG) {
				System.out.println("Accepted connection from " + socket.getInetAddress());
			}
			socket.setSoTimeout(1000 * 30);

			OutputStream os = socket.getOutputStream();
			InputStream is = socket.getInputStream();
			out = new DataOutputStream(new BufferedOutputStream(os));
			in = new LineInputStream(new BufferedInputStream(is));

			String line;
			line = in.readLine();
			if (OCSPServer.DEBUG) {
				System.out.println("Received request from " + socket.getInetAddress() + ":");
				System.out.println(line);
			}
			StringTokenizer token = new StringTokenizer(line, " ");
			String method = token.nextToken();
			boolean usePOST = method.equalsIgnoreCase("POST");
			String requestString = null;
			if (!usePOST) {
				if (!method.equalsIgnoreCase("GET")) {
					if (OCSPServer.DEBUG) {
						System.out.println("Invalid method: " + method
						    + ". Only POST and GET supported.");
						System.out.println("Sending ERROR.");
					}
					writeError(out, "HTTP/1.0 405 Method Not Allowed");
					return;
				}
				// GET request
				requestString = token.nextToken();
				if ((requestString == null) || (requestString.length() == 0)) {
					if (OCSPServer.DEBUG) {
						System.out.println("Invalid GET request. No OCSP request included.");
						System.out.println("Sending ERROR.");
					}
					writeError(out, "HTTP/1.0 400 Invalid request");
					return;
				}
			}
			boolean invalidRequest = false;
			// print header lines
			do {
				line = in.readLine();
				if (OCSPServer.DEBUG) {
					System.out.println(line);
				}
				line = line.toLowerCase();
				if (line.startsWith("content-type")
				    && (line.indexOf("application/ocsp-request") == -1)) {
					invalidRequest = true;
				}
			} while ((line != null) && (line.length() != 0));
			if (OCSPServer.DEBUG) {
				System.out.println();
			}

			if ((invalidRequest) && (usePOST)) {
				if (OCSPServer.DEBUG) {
					System.out.println("Invalid request content type.");
					System.out.println("Sending ERROR.");
				}
				writeError(out, "HTTP/1.0 400 Invalid request");
				return;
			}
			// parse the request received
			if (OCSPServer.DEBUG) {
				System.out.println("Parse request...");
			}
			InputStream requestIn = in;
			if (!usePOST) {
				// GET request
				if ((requestString == null) || (requestString.length() == 0)) {
					writeError(out, "HTTP/1.0 400 Invalid request");
					return;
				}
				if (requestString.startsWith("/")) {
					requestString = requestString.substring(1);
				}
				try {
					byte[] request = Util.fromBase64String(URLDecoder.decode(requestString));
					requestIn = new ByteArrayInputStream(request);
				} catch (Exception ex) {
					writeError(out, "HTTP/1.0 400 Invalid request");
					return;
				}
			}
			OCSPResponse response = responseGenerator.createOCSPResponse(requestIn, null,
			    signatureAlgorithm, null);
			byte[] encodedResponse = response.getEncoded();
			// now create and send the response
			if (OCSPServer.DEBUG) {
				System.out.println("Sending response...\n");
			}
			writeHeaders(out, response, encodedResponse, !usePOST);
			out.write(encodedResponse);
			out.flush();
			out.close();
		} catch (IOException ex) {
			ex.printStackTrace();
		} finally {
			if (out != null) {
				try {
					out.close();
				} catch (IOException ex) {
					// ignore
				}
			}

			if (in != null) {
				try {
					in.close();
				} catch (IOException ex) {
					// ignore
				}
			}

			if (socket != null) {
				try {
					socket.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
	}

	/**
	 * Sends an error code.
	 * 
	 * @param out
	 *          the output stream to which to write the error code
	 * @param msg
	 *          the error message to be sent
	 * 
	 * @exception IOException
	 *              if an I/O error occurs
	 */
	private final static void writeError(DataOutputStream out, String msg)
	    throws IOException
	{
		out.writeBytes(msg);
		out.writeBytes(crlf);
		out.writeBytes("Server: IAIK-JCE OCSP Demo Server");
		out.writeBytes(crlf);
		out.writeBytes(crlf);
		out.flush();
		out.close();
	}

	/**
	 * Writes the response headers.
	 * 
	 * @param out
	 *          the output stream to which to write the headers
	 * @param response
	 *          the OCSP response
	 * @param encodedResponse
	 *          the encoded OCSP response
	 * @param lightweight
	 *          whether to write response headers required by the Lightweight OCSP
	 *          Profile (RFC 5019) (assumed when the request has been send by
	 *          using the http GET method)
	 * 
	 * @exception IOException
	 *              if an error occurs while writing the headers
	 */
	private final static void writeHeaders(DataOutputStream out,
	                                       OCSPResponse response,
	                                       byte[] encodedResponse,
	                                       boolean lightweight)
	    throws IOException
	{

		out.writeBytes("HTTP/1.0 200 OK");
		out.writeBytes(crlf);
		out.writeBytes("Content-Type: application/ocsp-response");
		out.writeBytes(crlf);
		out.writeBytes("Server: IAIK OCSP Demoserver");
		out.writeBytes(crlf);
		out.writeBytes("Content-Length: " + encodedResponse.length);
		out.writeBytes(crlf);
		if ((lightweight) && (response.getResponseStatus() == OCSPResponse.successful)) { // RFC 5019
			try {
				BasicOCSPResponse basicResponse = (BasicOCSPResponse) response.getResponse();
				SingleResponse singleResponse = basicResponse.getSingleResponses()[0];
				Date nextUpdate = singleResponse.getNextUpdate();
				Date thisUpdate = singleResponse.getThisUpdate();
				if (nextUpdate != null) {
					SimpleDateFormat dateFormat = new SimpleDateFormat(
					    "EEE, d MMM yyyy HH:mm:ss 'GMT'", Locale.US);
					dateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));
					out.writeBytes("Date: " + dateFormat.format(new Date()));
					out.writeBytes(crlf);
					out.writeBytes("Last-Modified: " + dateFormat.format(thisUpdate));
					out.writeBytes(crlf);

					out.writeBytes("Expires: " + dateFormat.format(nextUpdate));
					out.writeBytes(crlf);

					byte[] sha1Response = response.getFingerprint("SHA-1");
					out.writeBytes("ETag: \"" + Util.toString(sha1Response, "") + "\"");
					out.writeBytes(crlf);
					long updatePeriod = (nextUpdate.getTime() - thisUpdate.getTime()) / 1000 - 1000;
					if (updatePeriod > 0) {
						out.writeBytes("Cache-Control: max-age=" + updatePeriod
						    + ",public,no-transform,must-revalidate");
						out.writeBytes(crlf);
					}
				}
			} catch (Throwable t) {
				if (OCSPServer.DEBUG) {
					System.out.println("Error writing headers: " + t.toString());
				}
			}
		}
		out.writeBytes(crlf);

	}
}

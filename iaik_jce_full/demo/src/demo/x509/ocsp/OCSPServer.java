// Copyright (C) 2002 IAIK
// http://jce.iaik.at
//
// Copyright (C) 2003 - 2013 Stiftung Secure Information and
//                           Communication Technologies SIC
// http://www.sic.st
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

package demo.x509.ocsp;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.cert.CertificateFactory;
import java.util.Collection;
import java.util.Date;

import demo.IAIKDemo;
import demo.keystore.IaikKeyStore;

import iaik.asn1.structures.AlgorithmID;
import iaik.asn1.structures.Name;
import iaik.pkcs.pkcs12.PKCS12;
import iaik.security.provider.IAIK;
import iaik.utils.ASN1InputStream;
import iaik.utils.Util;
import iaik.x509.X509CRL;
import iaik.x509.X509Certificate;
import iaik.x509.extensions.ReasonCode;
import iaik.x509.ocsp.CertID;
import iaik.x509.ocsp.CertStatus;
import iaik.x509.ocsp.ReqCert;
import iaik.x509.ocsp.RevokedInfo;
import iaik.x509.ocsp.SingleResponse;
import iaik.x509.ocsp.utils.ResponseGenerator;

/**
 * A simple OCSP server.
 * <p>
 * This server is part of the IAIK OCSP client - server demo. When starting this
 * server, it listens on port 9999 for OCSP requests which may be sent by the
 * IAIK OCSP demo {@link demo.x509.ocsp.OCSPClient client}. For each request
 * posted an {@link demo.x509.ocsp.OCSPServerThread OCSPServerThread} is created
 * for handling the request.
 * <p>
 * The keys and certificates required for this demo are obtained from the
 * IAIK-JCE demo keystore "jce.keystore" which may be generated by running the
 * {@link demo.keystore.SetupKeyStore SetupKeyStore} program.
 * <p>
 * If you do not want to use the keys and certs from the demo keystore, you can
 * use a {@link iaik.x509.ocsp.utils.ResponseGenerator ResponseGenerator} to be
 * initialized by a CRL and key and cert of the response signer. For doing so
 * you first have to create a response generator repository of cached single
 * responses and write it to a file:
 * 
 * <pre>
 * java demo.ocsp.OCSPServer pkcs12File password crlFile [crlIssuerCert] outputFile
 * </pre>
 * 
 * where <code>pkcs12File</code> holds key and certs of the response signer,
 * <code>password</code> is the password to be used for decrypting the PKCS12
 * object, <code>crlFile</code> contains the CRL from which to precompute single
 * responses, <code>crlIssuerCert</code> supplies the cert of the crl issuer
 * (only required when different from the response signer), and
 * <code>outputFile</code> is the file to which to write the response generator
 * output (see {@link iaik.x509.ocsp.utils.ResponseGenerator ResponseGenerator}
 * for more information about the response generator operation modes).
 * <p>
 * After having created a response generator repository file you can use it for
 * initializing this server to respond to client requests:
 * 
 * <pre>
 * java demo.ocsp.OCSPServer pkcs12File password generatorContentFile
 * </pre>
 * 
 * where <code>pkcs12File</code> and <code>password</code> have the same meaning
 * as above, and <code>generatorContentFile</code> is the file created from
 * above named <code>outputFile</code> holding the single responses created from
 * the crl.
 * 
 * @see demo.x509.ocsp.OCSPServerThread
 * @see demo.x509.ocsp.OCSPClient
 * @see demo.x509.ocsp.HttpOCSPClient
 * @see iaik.x509.ocsp.utils.ResponseGenerator
 * @version File Revision <!-- $$Revision: --> 21 <!-- $ -->
 */
public class OCSPServer implements IAIKDemo {
	/**
	 * Default Port number.
	 */
	private final static int DEFAULT_PORT = 9999;
	/**
	 * Use an OCSP ResponseGenerator for request parsing / response generation.
	 */
	private ResponseGenerator responseGenerator;
	/**
	 * Algorithm to be used for signing the response.
	 */
	private AlgorithmID signatureAlgorithm;
	/**
	 * Debug mode enabled?
	 */
	public static final boolean DEBUG = true;

	/**
	 * Server socket.
	 */
	ServerSocket serverSocket_;

	/**
	 * Port number.
	 */
	int port_;

	/**
	 * Creates an OCSP server for the supplied OCSP object.
	 * 
	 * @param responseGenerator
	 *          a {@link iaik.x509.ocsp.utils.ResponseGenerator ResponseGenerator}
	 *          object used for request parsing and response creation tasks
	 * @param signatureAlgorithm
	 *          the algorithm used for signing the response
	 */
	public OCSPServer(ResponseGenerator responseGenerator, AlgorithmID signatureAlgorithm) {
		this(DEFAULT_PORT, responseGenerator, signatureAlgorithm);
	}

	/**
	 * Creates an OCSP server for the supplied OCSP object.
	 * 
	 * @param port
	 *          the port to listen on (default 9999)
	 * @param responseGenerator
	 *          a {@link iaik.x509.ocsp.utils.ResponseGenerator ResponseGenerator}
	 *          object used for request parsing and response creation tasks
	 * @param signatureAlgorithm
	 *          the algorithm used for signing the response
	 */
	public OCSPServer(int port,
	                  ResponseGenerator responseGenerator,
	                  AlgorithmID signatureAlgorithm)
	{
		if (responseGenerator == null) {
			throw new IllegalArgumentException(
			    "Cannot create OCSP server object. Missing response generator.");
		}
		if (signatureAlgorithm == null) {
			throw new IllegalArgumentException(
			    "Cannot create OCSP server object. Missing signature algorithm.");
		}
		port_ = (port < 0) ? DEFAULT_PORT : port;
		this.responseGenerator = responseGenerator;
		this.signatureAlgorithm = signatureAlgorithm;
	}

	/**
	 * Starts the OCSP Server.
	 */
	public void start() {

		if (serverSocket_ == null) {
			try {
				serverSocket_ = new ServerSocket(port_);
			} catch (IOException e) {
				System.err.println("Error binding to port " + port_ + ":");
				e.printStackTrace();
				return;
			}
		}
		System.out.println("Listening for OCSP request over HTTP on port " + port_ + "...");

		// a thread for each new Request
		while (true) {
			if (serverSocket_ != null) {
				try {
					Socket socket = serverSocket_.accept();
					(new OCSPServerThread(socket, responseGenerator,
					    (AlgorithmID) signatureAlgorithm.clone())).start();
				} catch (IOException e) {
					if (DEBUG) {
						e.printStackTrace();
					}
				}
			} else {
				break;
			}
		}

	}

	/**
	 * Stops the OCSP Server.
	 */
	public void stop() {
		if (serverSocket_ != null) {
			ServerSocket serverSocket = serverSocket_;
			serverSocket_ = null;
			try {
				serverSocket.close();
			} catch (Exception ex) {
				// ignore
			}
		}
		serverSocket_ = null;
	}

	/**
	 * Starts the test.
	 */
	public static void main0(String args[])
	    throws Exception
	{

		Security.insertProviderAt(new IAIK(), 2);
		ResponseGenerator responseGenerator = null;
		AlgorithmID signatureAlgorithm = null;

		if ((args != null) && (args.length > 0)) {
			// Init server from file
			if (args.length == 3) {
				System.out.println("Reading responder key from PKCS#12 file " + args[0] + "...");
				PKCS12 pkcs12 = readPKCS12File(args[0]);
				String pwd = args[1];
				System.out.println("Creating response generator...");
				responseGenerator = new ResponseGenerator(pkcs12, pwd.toCharArray());
				responseGenerator.printDebug(DEBUG);
				signatureAlgorithm = AlgorithmID.sha1WithRSAEncryption;
				PrivateKey responderKey = responseGenerator.getResponderKey();
				if (!(responderKey instanceof java.security.interfaces.RSAPrivateKey)) {
					if (responderKey instanceof java.security.interfaces.DSAPrivateKey) {
						signatureAlgorithm = AlgorithmID.dsa;
					} else {
						System.out.println("Error in initialization. Unknown key algorithm: "
						    + responderKey.getAlgorithm());
						Util.waitKey();
						System.exit(-1);
					}
				}
				System.out.println("Algorithm used for response signing will be: "
				    + signatureAlgorithm.getName());
				System.out.println("Initializing response generator from " + args[2] + "...");
				InputStream is = null;
				try {
					is = new FileInputStream(args[2]);
					responseGenerator.init(new BufferedInputStream(is));
				} catch (Exception ex) {
					System.out.println("Error during generator initialization:");
					ex.printStackTrace();
					Util.waitKey();
					System.exit(-1);
				} finally {
					if (is != null) {
						try {
							is.close();
						} catch (IOException ex) {
							// ignore
						}
					}
				}
				System.out.println("Initialization done!");

			} else if ((args.length == 4) || (args.length == 5)) {
				// create generator file from crl
				System.out.println("Read responder key from PKCS#12 file " + args[0] + "...");
				PKCS12 pkcs12 = readPKCS12File(args[0]);
				String pwd = args[1];
				System.out.println("Create response generator...");
				responseGenerator = new ResponseGenerator(pkcs12, pwd.toCharArray());
				responseGenerator.printDebug(DEBUG);
				signatureAlgorithm = AlgorithmID.sha1WithRSAEncryption;
				PrivateKey responderKey = responseGenerator.getResponderKey();

				if (!(responderKey instanceof java.security.interfaces.RSAPrivateKey)) {
					if (responderKey instanceof java.security.interfaces.DSAPrivateKey) {
						signatureAlgorithm = AlgorithmID.dsa;
					} else {
						System.out.println("Error in initialization. Unknown key algorithm: "
						    + responderKey.getAlgorithm());
						Util.waitKey();
						System.exit(-1);
					}
				}

				// read crl
				System.out.println("Read crl from " + args[2] + "...");
				X509CRL crl = readCrl(args[2]);
				X509Certificate crlIssuer = responseGenerator.getResponderCertificates()[0];
				if (args.length == 5) {
					// read crl issuer cert
					System.out.println("Read crl issuer cert from " + args[3] + "...");
					crlIssuer = readCert(args[3]);
				}
				System.out.println("Create response entries for crl...");
				responseGenerator.addResponseEntries(crl, crlIssuer, ReqCert.certID);
				System.out.println("Generator created:");
				System.out.println(responseGenerator);
				String outFileName = (args.length == 5) ? args[4] : args[3];
				System.out.println("Write generator contents to " + outFileName + "...");
				OutputStream os = null;
				try {
					os = new BufferedOutputStream(new FileOutputStream(outFileName));
					responseGenerator.writeTo(os);
					System.out.println("Finished!");
					Util.waitKey();
					System.exit(0);
				} catch (Exception ex) {
					System.out.println("Error writing to " + outFileName + ":");
					ex.printStackTrace();
					Util.waitKey();
					System.exit(-1);
				} finally {
					if (os != null) {
						try {
							os.close();
						} catch (IOException e) {
							// ignore
						}
					}
				}
			} else {
				System.out.println("Usage: java OCSPServer [<responder key (PKCS12)> "
				    + "<password> " + "<generator infile>]");
				System.out.println("\nor (for genrating a generator init file):\n");
				System.out.println("       java OCSPServer [<responder key (PKCS12)> "
				    + "<password> " + "<crl file> " + "[<crl issuer cert file>] "
				    + "<generator out file>\n");
				Util.waitKey();
				System.exit(-1);
			}
		} else {
			// self test
			try {
				signatureAlgorithm = AlgorithmID.sha1WithRSAEncryption;
				X509Certificate[] responderCerts = new X509Certificate[] { IaikKeyStore
				    .getCaCertificate(IaikKeyStore.RSA) };
				PrivateKey responderKey = IaikKeyStore.getCaPrivateKey(IaikKeyStore.RSA);
				X509Certificate[] targetCerts = IaikKeyStore.getCertificateChain(
				    IaikKeyStore.RSA, IaikKeyStore.SZ_512);

				System.out.println("Initializing OCSP server...");
				// calculate certID
				// hash algorithm for CertID
				AlgorithmID hashAlgorithm = AlgorithmID.sha1;
				// issuer name
				Name issuerName = (Name) targetCerts[1].getSubjectDN();
				// issuer key
				PublicKey issuerKey = targetCerts[1].getPublicKey();
				// create the ReqCerts
				CertID certID = new CertID(hashAlgorithm, issuerName, issuerKey,
				    targetCerts[0].getSerialNumber());
				ReqCert reqCert = new ReqCert(ReqCert.certID, certID);
				ReqCert reqCert1 = new ReqCert(ReqCert.issuerSerial,
				    new iaik.pkcs.pkcs7.IssuerAndSerialNumber(targetCerts[1]));

				// create the response generator
				responseGenerator = new ResponseGenerator(responderKey, responderCerts);
				responseGenerator.printDebug(DEBUG);
				// we assume that target cert 0 is revoked
				Date date = new Date();
				ReasonCode reasonCode = new ReasonCode(ReasonCode.keyCompromise);
				RevokedInfo ri = new RevokedInfo(date);
				ri.setRevocationReason(reasonCode);
				SingleResponse s = new SingleResponse(reqCert, new CertStatus(ri), new Date());
				responseGenerator.addResponseEntry(s);
				// target cert 1 shall be good
				SingleResponse s1 = new SingleResponse(reqCert1, new CertStatus(), new Date());
				responseGenerator.addResponseEntry(s1);
				responseGenerator.addCertificateIssuer((Name) targetCerts[1].getSubjectDN());
				System.out.println("Initialization done");
			} catch (Exception ex) {
				System.err.println("Initialization failed");
				ex.printStackTrace();
				Util.waitKey();
				System.exit(-1);
			}
		}
		System.out.println("Starting server...");
		// start the OCSP server
		OCSPServer server = new OCSPServer(responseGenerator, signatureAlgorithm);
		server.start();
	}

	/**
	 * Reads a PKCS12 object from the given file.
	 * 
	 * @param fileName
	 *          the name of the PKCS#12 file
	 * @return the PKCS#12 object
	 */
	private static PKCS12 readPKCS12File(String fileName) {
		InputStream is = null;
		PKCS12 pkcs12 = null;
		try {
			is = new FileInputStream(fileName);
			pkcs12 = new PKCS12(new ASN1InputStream(is));
		} catch (Exception ex) {
			System.out.println("Error reading PKCS12 file " + fileName + ":");
			ex.printStackTrace();
			Util.waitKey();
			System.exit(-1);
		} finally {
			if (is != null) {
				try {
					is.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
		return pkcs12;
	}

	/**
	 * Reads a certificate from the given file.
	 * 
	 * @param fileName
	 *          the name of the certificate file
	 * @return the certificate
	 */
	private static X509Certificate readCert(String fileName) {
		InputStream is = null;
		X509Certificate cert = null;
		try {
			// get a new instance of a CertificateFactory
			CertificateFactory factory = CertificateFactory.getInstance("X.509", "IAIK");
			is = new FileInputStream(fileName);
			Collection c = factory.generateCertificates(new ASN1InputStream(is));
			Object[] certificates = c.toArray();
			X509Certificate[] certs = new X509Certificate[certificates.length];
			for (int i = 0; i < certificates.length; i++) {
				certs[i] = (X509Certificate) certificates[i];
			}
			if (certs.length > 1) {
				certs = Util.arrangeCertificateChain(certs, false);
				if (certs[0] == null) {
					System.out.println("Error reading cert from " + fileName
					    + ": Cannot sort chain!");
				}
			}
			cert = certs[0];
		} catch (Exception ex) {
			System.out.println("Error reading cert from " + fileName + ":");
			ex.printStackTrace();
			Util.waitKey();
			System.exit(-1);
		} finally {
			if (is != null) {
				try {
					is.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
		return cert;
	}

	/**
	 * Reads a X.509 crl from the given file.
	 * 
	 * @param fileName
	 *          the name of the crl file
	 * @return the crl
	 */
	private static X509CRL readCrl(String fileName) {
		InputStream is = null;
		X509CRL crl = null;
		try {
			is = new FileInputStream(fileName);
			crl = new X509CRL(new ASN1InputStream(is));
		} catch (Exception ex) {
			System.out.println("Error reading crl file " + fileName + ":");
			ex.printStackTrace();
			Util.waitKey();
			System.exit(-1);
		} finally {
			if (is != null) {
				try {
					is.close();
				} catch (IOException e) {
					// ignore
				}
			}
		}
		return crl;
	}

	/**
	 * The main method.
	 */
	public static void main(String args[]) {
		try {
			main0(args);
		} catch (Throwable e) {
			System.err.println("An error occured:");
			e.printStackTrace(System.err);
		}
		// wait for key press
		iaik.utils.Util.waitKey();
	}
}
